---
layout: post
title: Haskell's WebDriver package is back in business
tags: [haskell]
---

## TL;DR

The [webdriver](https://hackage.haskell.org/package/webdriver) package has undergone some major changes and now supports Selenium 3 and 4 with the release of version [0.13.0.0](https://hackage.haskell.org/package/webdriver-0.13.0.0)!

## Some history

This project has been on autopilot for a while now. Originally written by [@erratic-pattern](https://github.com/erratic-pattern), the library spoke the Selenium JSON wire protocol for controlling browsers via Selenium 2. However, the world began to change when Selenium 3 came out, with support for a new [W3C protocol](https://www.w3.org/TR/webdriver2/) with some notable new features like [Action chains](https://www.w3.org/TR/webdriver2/#dfn-actions).

Then Selenium 4 came out, which marked the legacy wire protocol as deprecated. It was time for some major updates to keep this package up to date.

As a heavy WebDriver user, I got Hackage maintainer access in November 2022 to help keep it running, making small tweaks to support dependency updates and new GHC versions etc. In April 2023 we got the [haskell-webdriver](https://github.com/haskell-webdriver) organization created on GitHub as the new home of the project. That year [@dten](https://github.com/dten) made a couple nice contributions.

The push towards real progress was started by [PR #144](https://github.com/haskell-webdriver/haskell-webdriver/pull/144), which was actualy first opened by [@cfraz89](https://github.com/cfraz89) in 2018. This PR updated some API calls and data structures to use W3C-compatible versions, and served as a starting point when I began trying to do the upgrade in earnest.

In the rest of this blog post I'll mention some interesting aspects of this update, for posterity's sake and hopefully to inspire some people to migrate to the new version and use the package.

## Process lifecycle management

One of the hardest things about using this package in the past is that you had to manage Selenium yourself! This meant installing the Selenium server, plus the driver program(s) you need such as [ChromeDriver](https://developer.chrome.com/docs/chromedriver) or [geckodriver](https://github.com/mozilla/geckodriver), plus whatever browsers you needed. In particular, you had to make sure the driver programs were compatible with the browsers. In the bad old days, you had to access an obscure Google server to find a table of which ChromeDriver versions were compatible with which Chrome versions.

After obtaining all the executables you needed, you then had to launch the Selenium process yourself, make sure it started up successfully, and obtain the port number it was running on. Selenium's default port is 4444, but if you wanted to be able to run more than one test simultaneously, you had to get it to use a random port and then figure out what port it chose. To this day there isn't a good programmatic way to do this; you have to parse the output of the Selenium process. Once you had the port, you could configure this library to speak to it.

Now, the world is somewhat different. You can still use Selenium, but ChromeDriver and geckodriver are W3C-compliant WebDriver servers in their own right. So if you want to avoid some complexity and don't care about any Selenium-specific features, you can just run against a driver directly. But you can also run in the traditional mode where you start a Selenium server, and it starts the drivers for you.

To make this easy to work with, version `0.13.0.0` handles process launching for you. First you make a `WebDriverContext` by calling [`mkEmptyWebDriverContext`](https://hackage-content.haskell.org/package/webdriver-0.13.0.0/docs/Test-WebDriver.html#v:mkEmptyWebDriverContext). Then, you can launch a WebDriver session with the `startSession` function:

```haskell
startSession :: (WebDriverBase m, MonadMask m, MonadLogger m)
  => WebDriverContext
  -> DriverConfig -- Desired driver config (Selenium standalone, ChromeDriver, GeckoDriver, etc.)
  -> Capabilities -- W3C Capabilities
  -> String -- Session name
  -> m Session
```

The `WebDriverContext` is an opaque type in which we track all processes that we launch and sessions we create. When you're done, just call [`teardownWebDriverContext`](https://hackage-content.haskell.org/package/webdriver-0.13.0.0/docs/Test-WebDriver.html#v:teardownWebDriverContext) to tear down all sessions and stop all processes.

This design allows us to smooth over some oddities between different drivers. For example, a single geckodriver instance can't start multiple Firefox sessions (see [here](https://github.com/mozilla/geckodriver/issues/1946)). So, we automatically spin up a separate geckodriver process for every session.

## Tests!

The original package didn't have any tests. Presumably this was due to the difficulties discussed in the previous section of setting up WebDriver configurations in the past.



## Cleaning up some module proliferation

If you compare version [0.12.0.0](https://hackage-content.haskell.org/package/webdriver-0.12.0.0) to [0.13.0.0](https://hackage-content.haskell.org/package/webdriver-0.13.0.0), you can see that the module hierarchy has been cleaned up quite a bit.

## Simpler `Test.WebDriver.Profile`

## MonadBaseControl -> MonadUnliftIO

The monad design of the original package looked like this:

```haskell
-- |A class for monads that carry a WebDriver session with them. The
-- MonadBaseControl superclass is used for exception handling through
-- the lifted-base package.
class (Monad m, Applicative m) => WDSessionState m where

  -- |Retrieves the current session state of the monad
  getSession :: m WDSession

  -- |Sets a new session state for the monad
  putSession :: WDSession -> m ()

type WDSessionStateControl s = (WDSessionState s, MonadBaseControl IO s)

class (WDSessionStateControl wd) => WebDriver wd where
  doCommand :: (HasCallStack, ToJSON a, FromJSON b) =>
                   Method      -- ^HTTP request method
                -> Text        -- ^URL of request
                -> a           -- ^JSON parameters passed in the body
                               -- of the request. Note that, as a special case,
                               -- anything that converts to Data.Aeson.Null will
                               -- result in an empty request body.
                -> wd b        -- ^The JSON result of the HTTP request.
```
